parameters:
  job:
    name: ''
    displayName: ''
  pool: ''
  services:
    db4it: ''
  build:
    configuration: 'Release'
  sonar:
    enabled: True
    buildBreaker:
      enabled: True
  publishPipelineArtifacts: False

jobs:
- job: ${{ parameters.job.name }}
  displayName: ${{ parameters.job.displayName }}
  continueOnError: False
  pool: ${{ parameters.pool }}
  workspace:
    clean: all
  services:
    # The right side name has been declared in the 'containers' section found inside the 'azure-pipelines.yml' file.
    db4it: ${{ parameters.services.db4it }}
  steps:
  # Install specific .NET Core SDK version.
  # See more here: https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/tool/dotnet-core-tool-installer?view=azure-devops.
  # Installing a specific .NET Core SDK version is needed to avoid installing a .NET Core global tool in a following task and then have Azure DevOps complain that it cannot find it.
  # This issue is documented here: https://github.com/Microsoft/azure-pipelines-tasks/issues/8291.
  - task: DotNetCoreInstaller@0
    name: install_dotnetcore_sdk
    displayName: Install .NET Core SDK
    enabled: True
    inputs:
      packageType: 'sdk'
      version: $(DotNetCore_SDK_Version)

  # Install sonarscanner tool to be able to perform a SonarQube analysis.
  # See more here: https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild.
  # See more about "script" step here: https://docs.microsoft.com/en-us/azure/devops/pipelines/scripts/cross-platform-scripting?view=azure-devops&tabs=yaml
  # and here: https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/utility/command-line?view=azure-devops&tabs=yaml#yaml-snippet.
  # The long YAML line has been split using "block chomping indicator", as documented here: https://stackoverflow.com/a/3790497.
  - script: >-
      dotnet tool install dotnet-sonarscanner 
      --global 
      --version $(SonarScanner_Version)
    name: install_sonarscanner
    displayName: Install SonarQube static code analyzing CLI tool
    condition: |
      and
      (
          succeeded()
        , eq( ${{ parameters.sonar.enabled }}, True)
      )
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: $(DotNetSkipFirstTimeExperience)
      DOTNET_CLI_TELEMETRY_OPTOUT: $(DotNetCliTelemetryOptOut)
      COREHOST_TRACE: $(CoreHostTrace)

  # Prepare SonarQube analysis.
  # See more here: https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild.
  #
  # You need to define a variable group named "SonarQube" and add several variables:
  #   - SonarProjectKey - contains the key used for connecting to the project hosted on SonarCloud
  #   - SonarProjectVersion - specifies the version to attach to this SonarQube analysis
  # Then map this group to the "variables" section of this pipeline.
  #
  # The analysis will make use of the branch name via the "sonar.branch.name" command parameter.
  # See more here: https://sonarcloud.io/documentation/branches/overview/#analysis.
  - script: >-
      dotnet-sonarscanner begin 
      /k:"$(CurrentProject.Sonar.ProjectKey)" 
      /v:"$(CurrentProject.Version)"
      /s:"$(Build.SourcesDirectory)/Build/SonarQubeAnalysis.xml" 
      /d:sonar.login="$(CurrentProject.Sonar.Token)" 
      /d:sonar.branch.name="$(Build.SourceBranchName)"
    name: prepare_sonarqube_analysis
    displayName: Prepare SonarQube analysis
    condition: |
      and
      (
          succeeded()
        , eq( ${{ parameters.sonar.enabled }}, True)
      )
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: $(DotNetSkipFirstTimeExperience)
      DOTNET_CLI_TELEMETRY_OPTOUT: $(DotNetCliTelemetryOptOut)
      COREHOST_TRACE: $(CoreHostTrace)    

  # Compile source code.
  # See more here: https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/build/dotnet-core-cli?view=azure-devops.
  - script: >-
      dotnet build $(Build.SourcesDirectory)/Todo.sln 
      --configuration ${{ parameters.build.configuration }}
    name: build_sources
    displayName: Build sources
    enabled: True
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: $(DotNetSkipFirstTimeExperience)
      DOTNET_CLI_TELEMETRY_OPTOUT: $(DotNetCliTelemetryOptOut)
      COREHOST_TRACE: $(CoreHostTrace)

  # Run unit tests and collect code coverage metrics.
  # See more about running selective tests here: https://docs.microsoft.com/en-us/dotnet/core/testing/selective-unit-tests#xunit.
  # Decorate the AssemblyInfo.cs found inside each unit test related project with:
  #     [assembly: NUnit.Framework.Category("IntegrationTests")]
  - script: >-
      dotnet test $(Build.SourcesDirectory)/Todo.sln 
      --no-build
      --configuration ${{ parameters.build.configuration }} 
      --filter "Category=UnitTests" 
      --test-adapter-path "."
      --logger "nunit" 
      /p:CollectCoverage=True 
      /p:CoverletOutputFormat=opencover 
      /p:Include="[Todo.*]*"
      /p:Exclude="[Todo.*.*Tests]*"
    name: run_unit_tests
    displayName: Run unit tests
    enabled: True
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: $(DotNetSkipFirstTimeExperience)
      DOTNET_CLI_TELEMETRY_OPTOUT: $(DotNetCliTelemetryOptOut)
      COREHOST_TRACE: $(CoreHostTrace)  

  # Publish unit test results inside the build 'Tests' tab.
  # See more here: https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/test/publish-test-results?view=azure-devops&tabs=yaml.
  - task: PublishTestResults@2
    displayName: Publish unit test results
    name: publish_unit_test_results
    condition: succeededOrFailed()
    enabled: True
    inputs:
      testResultsFormat: 'NUnit'
      testResultsFiles: '**/UnitTests/**/TestResults/*'
      mergeTestResults: True
      buildConfiguration: ${{ parameters.build.configuration }}
      publishRunAttachments: True  

  # Run integration tests and collect code coverage metrics.
  # Decorate the AssemblyInfo.cs found inside each integration test related project with:
  #     [assembly: NUnit.Framework.Category("IntegrationTests")]
  - script: >-
      dotnet test $(Build.SourcesDirectory)/Todo.sln 
      --no-build
      --configuration ${{ parameters.build.configuration }} 
      --filter "Category=IntegrationTests" 
      --test-adapter-path "."
      --logger "nunit" 
      /p:CollectCoverage=True 
      /p:CoverletOutputFormat=opencover 
      /p:Include="[Todo.*]*"
      /p:Exclude="[Todo.*.*Tests]*"
    name: run_integration_tests
    displayName: Run integration tests
    enabled: True
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: $(DotNetSkipFirstTimeExperience)
      DOTNET_CLI_TELEMETRY_OPTOUT: $(DotNetCliTelemetryOptOut)
      COREHOST_TRACE: $(CoreHostTrace) 
      # TODO: satrapu 2019-05-01 Find a way to replace hard-coded sensitive data with something more secure. 
      CONNECTIONSTRINGS__TODO: >-
        Host=localhost;
        Port=$(Agent.Services.db4it.Ports.5432);
        Database=todo;
        Username=satrapu;
        Password=;

  # Publish integration test results inside the build 'Tests' tab.
  # See more here: https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/test/publish-test-results?view=azure-devops&tabs=yaml.
  - task: PublishTestResults@2
    displayName: Publish integration test results
    name: publish_integration_test_results
    condition: succeededOrFailed()
    enabled: True
    inputs:
      testResultsFormat: 'NUnit'
      testResultsFiles: '**/IntegrationTests/**/TestResults/*'
      mergeTestResults: True
      buildConfiguration: ${{ parameters.build.configuration }}
      publishRunAttachments: True  

  # Publish test results as pipeline artifacts.
  # See more here: https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/pipeline-artifacts?view=azure-devops&tabs=yaml#publish-a-pipeline-artifact.
  #
  # This task will make use of the ~/Tests/.artifactignore file.
  # See more here: https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/pipeline-artifacts?view=azure-devops&tabs=yaml#using-artifactignore-files.
  - task: PublishPipelineArtifact@0
    displayName: Publish test results as pipeline artifacts
    name: publish_test_results_as_pipeline_artifacts
    condition: |
      and
      (
          succeededOrFailed()
        , eq( ${{ parameters.publishPipelineArtifacts }}, True)
      )
    inputs:
      artifactName: 'test-results-$(Agent.OS)-$(Agent.OSArchitecture)'
      targetPath: '$(Build.SourcesDirectory)/Tests'

  # Install reportgenerator tool to be able to generate code coverage related reports.
  - script: >-
      dotnet tool install dotnet-reportgenerator-globaltool 
      --global 
      --version $(ReportGenerator_Version)
    name: install_code_coverage_report_generator
    displayName: Install code coverage report generator tool
    enabled: True
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: $(DotNetSkipFirstTimeExperience)
      DOTNET_CLI_TELEMETRY_OPTOUT: $(DotNetCliTelemetryOptOut)
      COREHOST_TRACE: $(CoreHostTrace)    

  # Generate code coverage report:
  #   - combine several OpenCover coverage data files into one single file in Cobertura format
  #   - generate coverage HTML report ready to be displayed by Azure DevOps
  #   - generate coverage badge to be displayed on GitHub project home page
  # See more here: https://github.com/danielpalme/ReportGenerator#usage.
  # See more about the output formats here: https://github.com/danielpalme/ReportGenerator/wiki/Output-formats.
  # In order to be able to see the report inside the Code Coverage tab on Azure DevOps, 
  # enable Azure Boards for your project, as documented here: https://developercommunity.visualstudio.com/solutions/403137/view.html.
  - script: >-
      reportgenerator 
      "-reports:$(Build.SourcesDirectory)/Tests/**/coverage.opencover.xml" 
      "-targetdir:$(Build.SourcesDirectory)/.CodeCoverageReport" 
      "-reporttypes:Cobertura;HtmlInline_AzurePipelines;HtmlSummary;Badges"
    name: generate_code_coverage_report
    displayName: Generate code coverage report
    enabled: True

  # Publish code coverage report.
  # See more here: https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/test/publish-code-coverage-results?view=azure-devops.
  - task: PublishCodeCoverageResults@1
    name: publish_code_coverage_report
    displayName: Publish code coverage report
    enabled: True
    inputs:
      codeCoverageTool: 'Cobertura'
      summaryFileLocation: '$(Build.SourcesDirectory)/.CodeCoverageReport/Cobertura.xml'
      reportDirectory: '$(Build.SourcesDirectory)/.CodeCoverageReport'

  # Upload SonarQube report to external service, SonarCloud.
  # See more here: https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild.
  - script: >-
      dotnet-sonarscanner end  
      /d:sonar.login="$(CurrentProject.Sonar.Token)"
    name: upload_sonarqube_report
    displayName: Upload SonarQube report
    condition: |
      and
      (
          succeeded()
        , eq( ${{ parameters.sonar.enabled }}, True)
      )
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: $(DotNetSkipFirstTimeExperience)
      DOTNET_CLI_TELEMETRY_OPTOUT: $(DotNetCliTelemetryOptOut)
      COREHOST_TRACE: $(CoreHostTrace)    

  # Runs a PowerShell script to break the build in case Sonar quality gate has failed.
  # See more here: https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/utility/powershell?view=azure-devops.
  - task: PowerShell@2
    name: sonar_build_breaker
    displayName: Run Sonar build breaker
    # See more about conditions here: https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devops&tabs=yaml.
    condition: |
      and
      (
          succeeded()
        , eq( ${{ parameters.sonar.enabled }}, True)
        , eq( ${{ parameters.sonar.buildBreaker.enabled }}, True)
      )
    inputs:
      targetType: 'filePath'
      filePath: '$(Build.SourcesDirectory)/Build/SonarBuildBreaker.ps1'
      arguments: >-
        -SonarToken "$(CurrentProject.Sonar.Token)" 
        -DotSonarQubeFolder "$(Agent.BuildDirectory)/.sonarqube"
      errorActionPreference: stop
      failOnStderr: True
      workingDirectory: $(Build.SourcesDirectory)
